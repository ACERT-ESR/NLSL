c  VERSION 1.0  (NLSPMC version)   2/5/99
***********************************************************************
c
c                           =======
c                            CSVEC
c                           =======
c
c       This subroutine attempts to calculate the eigenvector
c       of the tridiagonal matrix corresponding to the eigenvalue
c       x.  The subroutine is written for a general complex symmetric
c       tridiagonal matrix, and it is based on the subroutine INVERM
c       of Cullum & Willoughby, vol. II page 430; CSVEC may be used
c       also in the case of Hermitian complex calculation, since the
c       tridiagonal matrix generated by Lanczos (or cg) algorithm
c       is real symmetrix.
c
c	The normalization process of the resulting eigenvector is 
c	corrected for complex symmetric matrix: one can't use the 
c	Hermitian norm.
c		z = tr(V)*V; v = V / sqrt(z)
c
c			V ; un-normalized eigenvector
c			v ; normalized eigenvector
c			z ; Euclidean norm, complex number
c
c       modified from original AP routine by Sanghyuk Lee
c
c       Arguments:
c           a    diagonal T matrix elements
c           b    extradiagonal T matrix elements
c           v1   work space
c           v2   work space, on exit = normalized eigenvector
c           x    eigenvalue
c           err  |v2(n)|  error estimate for corresponding ritz vector for x
c           errv |T*v2-x*v2| error estimate on T-eigenvector
c           gr   real part right hand vector
c           gc   complex part right hand vector
c           intc work space
c           n    order of T
c           it   max number of iteration
c           iwr  write flag for error
c
c       Includes:
c              nlsdim.inc
c              rndoff.inc
c
c       Uses:
c              znormu.f
c              zdotu2.f
c
c***********************************************************************
c
       subroutine csvec(a,b,v1,v2,x,err,errv,gr,gc,intc,n,it)
c
       include 'limits.inc'
       include 'rndoff.inc'
c
       integer intc,n,it
       double precision err,errv,gr,gc
       complex*16 a,b,v1,v2,x
       dimension intc(mxstep),a(mxstep),b(mxstep),
     #           v1(mxstep),v2(mxstep),gr(mxstep),gc(mxstep)
c
       integer iter,mp1,mm1,i,ii,j
       double precision xu,norm,tsum,gsum
     #                  eps,eps3,eps4,zero,one
       complex*16 u,z,temp,ratio,betam,czero,csum,cerrv
       complex*16 znormu,zdotu2
       external znormu,zdotu2
c
       parameter (czero=(0.0D0,0.0D0),one=1.0D0,zero=0.0D0)
c
c#######################################################################
c
       if(n.gt.mxstep) then
         write(*,*)'n too big in csvec ',n,mxstep
         stop
       end if
       eps=100.0D0*rndoff
c
       do 10 i=1,mxstep
          gr(i)=zero
          gc(i)=zero
 10    continue
       gr(1)=one
       gc(1)=one
c
c-----------------------------------------------------------------------
c      parameters
c-----------------------------------------------------------------------
c
       iter=it
       mp1=n+1
       mm1=n-1
       betam=b(n)
       b(n)=czero
c
c  calculate scale and tolerance
       tsum=zero
       do 15 i=1,n
          tsum=tsum+cdabs(a(i))+cdabs(b(i))
 15     continue
c
       eps3=eps*tsum
       eps4=dble(n)*eps3
c
c  generate scaled right hand side
       gsum=zero
       do 20 i=1,n
          gsum=gsum+dabs(gr(i))+dabs(gc(i))
 20     continue
       gsum=eps4/gsum
c
c  initialize right hand side for inverse iteration
       do 30 i=1,n
          intc(i)=0
          v2(i)=gsum*dcmplx(gr(i),gc(i))
 30     continue
c
       it=1
c
c-----------------------------------------------------------------------
c      triangular factorization
c-----------------------------------------------------------------------
c
 40     continue
c
       u=a(1)-x
       z=b(1)
c
       do 60 i=2,n
          if (cdabs(b(i-1)).le.cdabs(u)) then
             v1(i-1)=z/u
             v2(i-1)=v2(i-1)/u
             v2(i)=v2(i)-b(i-1)*v2(i-1)
             ratio=b(i-1)/u
             u=a(i)-x-z*ratio
             z=b(i)
          else
             ratio=u/b(i-1)
             intc(i)=1
             v1(i-1)=a(i)-x
             u=z-ratio*v1(i-1)
             z=-ratio*b(i)
             temp=v2(i-1)
             v2(i-1)=v2(i)
             v2(i)=temp-ratio*v2(i)
          end if
 60     continue
c
       if (cdabs(u).le.rndoff) u=dcmplx(eps3,eps3)
c
c  back substitution
       v2(n)=v2(n)/u
       do 80 ii=1,mm1
          i=n-ii
          if (intc(i+1).ne.1) then
             v2(i)=v2(i)-v1(i)*v2(i+1)
          else
             v2(i)=(v2(i)-v1(i)*v2(i+1)-b(i+1)*v2(i+2))/b(i)
          end if
 80     continue
c
c-----------------------------------------------------------------------
c      tests for convergence of inverse iteration
c-----------------------------------------------------------------------
c
       norm=cdabs(v2(n))
       do 90 ii=1,mm1
          i=n-ii
          norm=norm+cdabs(v2(i))
 90     continue
c
       if (norm.ge.one) go to 110
c
       it=it+1
       if (it.gt.iter) go to 110
c
       xu=eps4/norm
       do 100 i=1,n
          intc(i)=0
          v2(i)=v2(i)*xu
 100    continue
c
       go to 40
c
 110    continue
c
       csum=znormu(v2,n)
c
       do 120 ii=1,n
          v2(ii)=v2(ii)/csum
 120    continue
c
       err=cdabs(v2(n))
c
       v1(n)=a(n)*v2(n)+b(n-1)*v2(n-1)-x*v2(n)
c
       do 130 j=2,mm1
          jm=mp1-j
          v1(jm)=a(jm)*v2(jm)+b(jm-1)*v2(jm-1)+b(jm)*v2(jm+1)-x*v2(jm)
 130    continue
c
       v1(1)=a(1)*v2(1)+b(1)*v2(2)-x*v2(1)
c
       cerrv=zdotu2(v1,v1,n)
       errv=cdabs(cerrv)
       if (it.gt.iter) errv=-errv
c
       b(n)=betam
c
       return
c
       end
